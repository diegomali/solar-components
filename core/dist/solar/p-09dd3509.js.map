{"version":3,"names":["dashToCamelCase","str","replace","g","toUpperCase","toArray","value","Array","assignByFormDataPath","target","path","pathTokens","split","map","p","i","actualTarget","lastTarget","length","test","tempActual","isArray","push","serializeForm","form","options","obj","prototype","slice","call","querySelectorAll","ignoreDisabled","forEach","field","name","indexOf","type","tagName","option","selected","checked","log","debug","FormBehavior","ComponentBehavior","constructor","this","fields","Map","preventUnsavedIsAttached","static","host","preventUnsaved","dataset","hasOwnProperty","disconnectedCallback","native","handleSubmit","ev","preventDefault","currentValidation","isValid","isUnchecked","checkValidity","then","errors","Object","keys","component","dispatchEvent","CustomEvent","attach","addEventListener","detach","removeEventListener","setValid","classList","remove","add","setInvalid","setUnchecked","window","e","confirmationMessage","event","returnValue","setChecked","cleanup","pristine","fieldsAsArray","from","values","f","addField","set","removeField","delete","async","Promise","all","state","valid","detail","serialize","__decorate","Bind","FormFieldBehavior","formAttached","closest","formBehavior","forNative","setDirty","isDirty","setTouched","isTouched","undefined","error","valueToAssert","validityState","validators","validator","nativeFormField","getNativeFormField","nativeValidity","validity","badInput","customError","patternMismatch","rangeOverflow","rangeUnderflow","stepMismatch","tooLong","tooShort","typeMismatch","valueMissing","fn","exec","err","assign","stillValid","validityTokens","__rest","find","hasError","buildErrorMessageByValidityState","addValidator","getCustomErrorMessagesFromInlineAttrs","attrs","attributes","key","filter","reduce","acc","getErrorMessages","messages","token"],"sources":["./src/utils/lang/string.ts","./src/utils/lang/to-array.ts","./src/utils/lang/assign-by-form-data-path.ts","./src/utils/serialize-form.ts","./src/behaviors/form-behavior/form-behavior.ts","./src/behaviors/form-behavior/form-field-behavior.ts"],"sourcesContent":["export const dashToCamelCase = str => str.replace(/-([a-z])/g, g => g[1].toUpperCase());\r\n","export function toArray<T>(value: T | T[]): T[] {\r\n  return value ?\r\n    value instanceof Array ? value : [ value ]\r\n    : [];\r\n}\r\n","/**\r\n * Used to assign into a object field, accessing it by it Form Data Path,\r\n * commonly used in PHP's form data parsing engine.\r\n * @param target The target Object that will be assigned.\r\n * @param path The Form Data Path to assign the value. Ex: `user[name]`.\r\n * @param value The value of the field.\r\n */\r\nexport function assignByFormDataPath(target, path, value) {\r\n  const pathTokens = path.split(/\\[/).map(p => p.replace(/\\]/, ''));\r\n  let i;\r\n  let actualTarget = target;\r\n  let lastTarget = null;\r\n  for (i = 0; i < pathTokens.length; i++) {\r\n    if (/^(\\s*|\\d+)$/.test(pathTokens[i])) {\r\n      if (!(lastTarget[pathTokens[i - 1]] instanceof Array)) {\r\n        lastTarget[pathTokens[i - 1]] = [];\r\n      }\r\n\r\n      const tempActual = actualTarget;\r\n      actualTarget = lastTarget[pathTokens[i - 1]];\r\n      lastTarget = tempActual;\r\n      continue;\r\n    }\r\n    if (Array.isArray(actualTarget)) {\r\n      actualTarget.push(actualTarget[pathTokens[i]] || {});\r\n    } else {\r\n      actualTarget[pathTokens[i]] = actualTarget[pathTokens[i]] || {};\r\n    }\r\n\r\n    lastTarget = actualTarget;\r\n    actualTarget = actualTarget[pathTokens[i]];\r\n  }\r\n\r\n  if (actualTarget instanceof Array) {\r\n    actualTarget.push(value);\r\n  } else {\r\n    lastTarget[pathTokens[i - 1]] = value;\r\n  }\r\n  return target;\r\n}\r\n","import { assignByFormDataPath } from './lang/assign-by-form-data-path';\r\n\r\n/**\r\n * The options that can be passed to the serializeForm function.\r\n */\r\nexport interface SerializeFormOptions {\r\n  /**\r\n   * The function will ignore fields that has the disabled property.\r\n   */\r\n  ignoreDisabled?: boolean;\r\n}\r\n\r\n/**\r\n * Serialize a Form element to JSON.\r\n * @param form The target form element.\r\n * @param options A set of custom options.\r\n */\r\nexport function serializeForm(form: HTMLFormElement, options: SerializeFormOptions = {}) {\r\n  const obj = {};\r\n\r\n  Array.prototype.slice.call(form.querySelectorAll('[name]' + (options.ignoreDisabled ? ':not([disabled])' : '')))\r\n    .forEach(field => {\r\n      if (field.name && ['file', 'reset', 'button'].indexOf(field.type) === -1 && field.tagName.indexOf('-') === -1) {\r\n        switch (field.type) {\r\n          case 'select-multiple':\r\n            const options = [];\r\n            Array.prototype.slice.call(field.options).forEach(option => {\r\n              if (option.selected) { options.push(option.value); }\r\n            });\r\n            assignByFormDataPath(obj, field.name, options);\r\n            break;\r\n\r\n          case 'checkbox':\r\n            if (field.checked) { assignByFormDataPath(obj, field.name, true); }\r\n          case 'radio':\r\n            if (field.checked) { assignByFormDataPath(obj, field.name, field.value); }\r\n            break;\r\n\r\n          default:\r\n            if (field.value) { assignByFormDataPath(obj, field.name, field.value); }\r\n            break;\r\n        }\r\n      }\r\n    });\r\n\r\n  return obj;\r\n}\r\n","import debug from 'debug/src/browser';\r\n\r\nimport { Bind } from '../../utils/lang/bind';\r\nimport { SerializeFormOptions, serializeForm } from '../../utils/serialize-form';\r\nimport { ComponentBehavior } from '../../utils/stencil/component-behavior';\r\nimport { CustomValidityState } from '../../utils/validations/validations';\r\n\r\nimport { FormFieldBehavior } from './form-field-behavior';\r\n\r\nconst log = debug('solar:FormBehavior');\r\n\r\n/**\r\n * Extend form features.\r\n */\r\nexport class FormBehavior extends ComponentBehavior<any> {\r\n  /**\r\n   * Instantiate a FormBehavior for a native Form element.\r\n   * @param host The target Form element.\r\n   */\r\n  static forNative(host: HTMLElement) {\r\n    return new FormBehavior({\r\n      host,\r\n      preventUnsaved: host.dataset.hasOwnProperty('preventUnsaved'),\r\n      disconnectedCallback: null,\r\n      native: true\r\n    });\r\n  }\r\n\r\n  /**\r\n   * All field that compound this Form.\r\n   */\r\n  private fields = new Map<string, FormFieldBehavior>();\r\n\r\n  /**\r\n   * Prevent user to leave the screen.\r\n   */\r\n  private preventUnsavedIsAttached = false;\r\n\r\n  /**\r\n   * True if this form is valid.\r\n   */\r\n  isValid: boolean;\r\n\r\n  /**\r\n   * True if the user has changed any field from the form.\r\n   */\r\n  isUnchecked: boolean;\r\n\r\n  /**\r\n   * Runs all validations from formBehavior's fields.\r\n   * If it is valid, propagates the formSubmit event to other listeners\r\n   */\r\n  @Bind\r\n  private handleSubmit(ev) {\r\n    log('Submitting', this);\r\n    ev.preventDefault();\r\n    const currentValidation = !!this.isValid;\r\n\r\n    if (!currentValidation || this.isUnchecked) {\r\n      this.checkValidity()\r\n        .then(errors => {\r\n          if (Object.keys(errors).length === 0) {\r\n            this.component.host.dispatchEvent(new CustomEvent('formSubmit'));\r\n          }\r\n        });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attach a listener to 'submit' to the formBehavior,\r\n   * preventing the form submission if it is invalid.\r\n   */\r\n  attach() {\r\n    log('Initializing', this);\r\n    this.component.host.addEventListener('submit', this.handleSubmit);\r\n  }\r\n\r\n  detach() {\r\n    this.component.host.removeEventListener('submit', this.handleSubmit);\r\n  }\r\n\r\n  /**\r\n   * Set the form in the valid state.\r\n   */\r\n  setValid() {\r\n    log('Set valid', this);\r\n    this.isValid = true;\r\n    this.component.host.classList.remove('form--invalid');\r\n    this.component.host.classList.add('form--valid');\r\n  }\r\n\r\n  /**\r\n   * Set the form in the invalid state.\r\n   */\r\n  setInvalid() {\r\n    log('Set invalid', this);\r\n    this.isValid = false;\r\n    this.component.host.classList.remove('form--valid');\r\n    this.component.host.classList.add('form--invalid');\r\n  }\r\n\r\n  /**\r\n   * Set the form in the unchecked state.\r\n   */\r\n  setUnchecked() {\r\n    log('Set unchecked', this);\r\n    this.isUnchecked = true;\r\n    this.isValid = false;\r\n    this.component.host.classList.remove('form--valid', 'form--invalid');\r\n    this.component.host.classList.add('form--unchecked');\r\n\r\n    // Prevent close the page with unsaved changes.\r\n    if (!this.preventUnsavedIsAttached &&\r\n      (this.component.preventUnsaved || this.component.preventUnsaved === '')) {\r\n      log('Preventing Unsaved');\r\n      window.addEventListener('beforeunload', e => {\r\n        if (this.isUnchecked) {\r\n          const confirmationMessage = this.component.preventUnsaved;\r\n\r\n          (e || window.event).returnValue = confirmationMessage; // Gecko + IE\r\n          return confirmationMessage; // Gecko + Webkit, Safari, Chrome etc.\r\n        }\r\n      });\r\n      this.preventUnsavedIsAttached = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the form in the checked state.\r\n   */\r\n  setChecked() {\r\n    log('Set checked', this);\r\n    this.isUnchecked = false;\r\n    this.component.host.classList.remove('form--unchecked');\r\n  }\r\n\r\n  /**\r\n   * Cleans all the states, errors and values of the form.\r\n   */\r\n  cleanup() {\r\n    log('Cleaning', this);\r\n    this.pristine();\r\n    const fieldsAsArray = Array.from(this.fields.values());\r\n    fieldsAsArray.forEach(f => f.cleanup());\r\n  }\r\n\r\n  /**\r\n   * Set the form in the pristine state, preserving values, removing the validations and unchecked.\r\n   */\r\n  pristine() {\r\n    log('Set pristine', this);\r\n    this.isValid = false;\r\n    this.isUnchecked = false;\r\n    this.component.host.classList.remove('form--unchecked', 'form--valid', 'form--invalid');\r\n  }\r\n\r\n  /**\r\n   * Adds a field to this logic. Note that the field must have a name.\r\n   * @param field A component's FormFieldBehavior\r\n   */\r\n  addField(field: FormFieldBehavior) {\r\n    this.fields.set(field.name, field);\r\n  }\r\n\r\n  /**\r\n   * Remove a field from this logic.\r\n   * @param field A component's FormFieldBehavior\r\n   */\r\n  removeField(field: FormFieldBehavior) {\r\n    this.fields.delete(field.name);\r\n  }\r\n\r\n  /**\r\n   * Runs all field validations from the formBehavior.\r\n   */\r\n  async checkValidity(): Promise<FormValidationErrors> {\r\n    log('Validating formBehavior', this);\r\n\r\n    this.setChecked();\r\n    const fieldsAsArray = Array.from(this.fields.values());\r\n    const errors = {};\r\n\r\n    await Promise.all(fieldsAsArray\r\n      .map(f => f.checkValidity()\r\n        .then(state => {\r\n          if (!state.valid) {\r\n            errors[f.name] = state;\r\n          }\r\n        })\r\n      ));\r\n\r\n    if (Object.keys(errors).length === 0) {\r\n      this.setValid();\r\n    } else {\r\n      this.setInvalid();\r\n      this.component.host.dispatchEvent(\r\n        new CustomEvent('formInvalid', { detail: errors })\r\n      );\r\n    }\r\n\r\n    return errors;\r\n  }\r\n\r\n  serialize(options?: SerializeFormOptions) {\r\n    log('Serializing', this.component.host, serializeForm(this.component.host, options));\r\n    return serializeForm(this.component.host, options);\r\n  }\r\n}\r\n\r\nexport interface FormValidationErrors {\r\n  [key: string]: {\r\n    errors: CustomValidityState\r\n  };\r\n}\r\n","import debug from 'debug/src/browser';\r\n\r\nimport { Bind } from '../../utils/lang/bind';\r\nimport { dashToCamelCase } from '../../utils/lang/string';\r\nimport { toArray } from '../../utils/lang/to-array';\r\nimport { ComponentBehavior } from '../../utils/stencil/component-behavior';\r\nimport { CustomValidityState, ValidatorFn } from '../../utils/validations/validations';\r\n\r\nimport { FormBehavior } from './form-behavior';\r\nimport { FormFieldComponent } from './form-field-component';\r\nimport { HTMLCustomFormElement } from './html-custom-form-element';\r\n\r\nconst log = debug('solar:FormFieldBehavior');\r\n\r\n/**\r\n * Adds form field features to a component, such as validations.\r\n */\r\nexport class FormFieldBehavior extends ComponentBehavior<FormFieldComponent> {\r\n\r\n  /**\r\n   * The form that this field is attached\r\n   */\r\n  private formAttached?: HTMLCustomFormElement;\r\n\r\n  /**\r\n   * The name of the field to use in the form.\r\n   */\r\n  name: string;\r\n\r\n  /**\r\n   * True if the value of this field is valid.\r\n   * Note that needs to call `validate` to ensure it.\r\n   */\r\n  isValid: boolean;\r\n\r\n  /**\r\n   * True if the user has interacted with this field before.\r\n   */\r\n  isTouched: boolean;\r\n\r\n  /**\r\n   * True if the user has changed this field's value before.\r\n   */\r\n  isDirty: boolean;\r\n\r\n  /**\r\n   * If this field is in a form, attach to it and initialize the FormLogic.\r\n   */\r\n  attach() {\r\n    this.name = this.component.name;\r\n    this.formAttached = this.component.host.closest('form') as HTMLCustomFormElement;\r\n\r\n    if (this.formAttached) {\r\n      log('Attaching', this.name, this.formAttached);\r\n      if (!this.formAttached.formBehavior) {\r\n        this.formAttached.formBehavior = FormBehavior.forNative(this.formAttached);\r\n      }\r\n      this.formAttached.formBehavior.addField(this);\r\n    }\r\n\r\n    this.component.host.addEventListener('invalid', this.checkValidity);\r\n  }\r\n\r\n  /**\r\n   * Removes this field from FormLogic, to ignore it validations.\r\n   */\r\n  detach() {\r\n    if (this.formAttached) {\r\n      log('Detaching', this.name, this.formAttached);\r\n      this.formAttached.formBehavior.removeField(this);\r\n    }\r\n\r\n    this.component.host.removeEventListener('invalid', this.checkValidity);\r\n  }\r\n\r\n  /**\r\n   * Set the field in the dirty state.\r\n   */\r\n  setDirty() {\r\n    log('Set dirty', this.name, this.formAttached);\r\n    this.component.host.classList.add('form-field--dirty');\r\n    this.isDirty = true;\r\n\r\n    if (this.formAttached) { this.formAttached.formBehavior.setUnchecked(); }\r\n  }\r\n\r\n  /**\r\n   * Set the field in the touched state.\r\n   */\r\n  setTouched() {\r\n    log('Set touched', this.name);\r\n    this.component.host.classList.add('form-field--touched');\r\n    this.isTouched = true;\r\n  }\r\n\r\n  /**\r\n   * Set the field in the valid state.\r\n   */\r\n  setValid() {\r\n    log('Set valid', this.name);\r\n    this.component.host.classList.add('form-field--valid');\r\n    this.component.host.classList.remove('form-field--invalid');\r\n\r\n    this.isValid = true;\r\n  }\r\n\r\n  /**\r\n   * Set the field in the invalid state\r\n   */\r\n  setInvalid() {\r\n    log('Set invalid', this.name);\r\n    this.component.host.classList.add('form-field--invalid');\r\n    this.component.host.classList.remove('form-field--valid');\r\n\r\n    this.isValid = false;\r\n  }\r\n\r\n  /**\r\n   * Cleans all the states, error and value of the field.\r\n   */\r\n  cleanup() {\r\n    log('Cleaning up', this.name);\r\n    this.component.host.classList.remove(\r\n      'form-field--invalid', 'form-field--valid', 'form-field--touched', 'form-field--dirty'\r\n    );\r\n    this.component.value = undefined;\r\n    this.component.error = undefined;\r\n    this.isValid = undefined;\r\n    this.isTouched = undefined;\r\n    this.isDirty = undefined;\r\n  }\r\n\r\n  /**\r\n   * Runs the all the validations of the field and sets the component's validity.\r\n   */\r\n  @Bind\r\n  async checkValidity(value?: any): Promise<CustomValidityState> {\r\n    const valueToAssert = value || this.component.value || '';\r\n    log('Validating', this.name, '=', valueToAssert);\r\n\r\n    let validityState: CustomValidityState = { valid: true };\r\n    const validators = toArray(this.component.validator);\r\n\r\n    const nativeFormField = this.component.getNativeFormField ? await this.component.getNativeFormField() : null;\r\n    if (nativeFormField) {\r\n      const nativeValidity = nativeFormField.validity;\r\n      validityState.badInput = nativeValidity.badInput;\r\n      validityState.customError = nativeValidity.customError;\r\n      validityState.patternMismatch = nativeValidity.patternMismatch;\r\n      validityState.rangeOverflow = nativeValidity.rangeOverflow;\r\n      validityState.rangeUnderflow = nativeValidity.rangeUnderflow;\r\n      validityState.stepMismatch = nativeValidity.stepMismatch;\r\n      validityState.tooLong = nativeValidity.tooLong;\r\n      validityState.tooShort = nativeValidity.tooShort;\r\n      validityState.typeMismatch = nativeValidity.typeMismatch;\r\n      validityState.valid = nativeValidity.valid;\r\n      validityState.valueMissing = nativeValidity.valueMissing;\r\n    }\r\n\r\n    // Running all validator functions\r\n    const formBehavior = this.formAttached ? this.formAttached.formBehavior : null;\r\n    for (const fn of validators) {\r\n      let state;\r\n      try {\r\n        const exec = fn(valueToAssert, this, formBehavior);\r\n        state = exec instanceof Promise ? await exec : exec;\r\n      } catch (err) {\r\n        log('Error in validator function', fn.name, err);\r\n      }\r\n\r\n      if (state) {\r\n        // Assign the custom validity tokens.\r\n        validityState = { ...validityState, ...state };\r\n\r\n        // If in the last verification it still valid\r\n        // so we gonna check the overall state again.\r\n        const { valid: stillValid, ...validityTokens } = validityState;\r\n        if (stillValid) {\r\n          validityState.valid = !Object.values(validityTokens)\r\n            .find(hasError => !!hasError);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (validityState.valid) {\r\n      this.component.error = null;\r\n      this.setValid();\r\n    } else {\r\n      this.component.error = this.buildErrorMessageByValidityState(validityState) || true;\r\n      this.setInvalid();\r\n      this.component.host.dispatchEvent(\r\n        new CustomEvent('formFieldInvalid', { detail: validityState })\r\n      );\r\n    }\r\n\r\n    this.component.validity = validityState;\r\n\r\n    return validityState;\r\n  }\r\n\r\n  /**\r\n   * Add a validator to the validation pipeline.\r\n   * @param validator The validation function.\r\n   */\r\n  addValidator(validator: ValidatorFn) {\r\n    if (!this.component.validator) {\r\n      this.component.validator = [];\r\n    } else if (!(this.component.validator instanceof Array)) {\r\n      this.component.validator = [ this.component.validator ];\r\n    }\r\n    this.component.validator.push(validator);\r\n\r\n    return this;\r\n  }\r\n\r\n  getCustomErrorMessagesFromInlineAttrs() {\r\n    const attrs = this.component.host.attributes;\r\n\r\n    return Object.keys(attrs)\r\n      .map(key => attrs[key].name)\r\n      .filter(key => key.indexOf('-message') > -1)\r\n      .reduce((acc, key) => {\r\n        acc[dashToCamelCase(key)] = attrs[key].value;\r\n        return acc;\r\n      }, {});\r\n  }\r\n\r\n  getErrorMessages() {\r\n    return this.getCustomErrorMessagesFromInlineAttrs();\r\n  }\r\n\r\n  buildErrorMessageByValidityState(validityState: CustomValidityState) {\r\n    const messages = this.getErrorMessages();\r\n\r\n    for (const token in validityState) {\r\n      if (validityState[token] && token !== 'valid') {\r\n        if (typeof validityState[token] === 'string') {\r\n          return validityState[token];\r\n        } else {\r\n          return messages[token + 'Message'];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"}