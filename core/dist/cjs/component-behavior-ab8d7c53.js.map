{"file":"component-behavior-ab8d7c53.js","mappings":";;AAAA;;;;;;;SAOgB,YAAY,CAAC,MAAW,EAAE,MAAc,EAAE,MAAiD;EACzG,MAAM,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;EAEhC,MAAM,CAAC,IAAI,GAAG,MAAM,GAAG,cAAc,CAAC,GAAG,MAAM,CAAC,IAAI,GAAG,MAAM,GAAG,WAAW,CAAC,IAAI,EAAE,CAAC;EACnF,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,GAAG,MAAM,GAAG,cAAc,CAAC,CAAC;EAEzD,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;EAEvB,MAAM,CAAC,MAAM,CAAC,GAAG,UAAS,GAAG,IAAI;IAC/B,IAAI,UAAU,CAAC;IACf,KAAK,MAAM,KAAK,IAAI,SAAS,EAAE;MAC7B,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,QAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,EAAE,IAAI,CAAC,CAAC;KAC5E;IACD,OAAO,UAAU,CAAC;GACnB,CAAC;AACJ;;ACIA;;;MAGa,iBAAiB;EAqB5B,YAAY,SAAY;IACtB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC3B,IAAI,IAAI,CAAC,YAAY,EAAE;MAAE,IAAI,CAAC,YAAY,EAAE,CAAC;KAAE;;IAG/C,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE;MACzB,OAAO,CAAC,IAAI,CAAC,0CAA0C,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;MACzE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,GAAG;QAC3B,IAAI,CAAC,SAAS,CAAC,oBAAoB,EAAE,CAAC;QACtC,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;OACrD,CAAC;MACF,UAAU,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,gBAAgB,EAAE,EAAE,CAAC,CAAC,CAAC;KACxD;IAED,YAAY,CAAC,IAAI,CAAC,SAAS,EAAE,kBAAkB,EAAE,gBAAgB;MAC/D,IAAI,gBAAgB,EAAE;QAAE,gBAAgB,EAAE,CAAC;OAAE;MAC7C,IAAI,IAAI,CAAC,MAAM,EAAE;QAAE,IAAI,CAAC,MAAM,EAAE,CAAC;OAAE;KACpC,CAAC,CAAC;IAEH,YAAY,CAAC,IAAI,CAAC,SAAS,EAAE,sBAAsB,EAAE,oBAAoB;MACvE,IAAI,oBAAoB,EAAE;QAAE,oBAAoB,EAAE,CAAC;OAAE;MACrD,IAAI,IAAI,CAAC,MAAM,EAAE;QAAE,IAAI,CAAC,MAAM,EAAE,CAAC;OAAE;KACpC,CAAC,CAAC;GACJ;;;;;;","names":[],"sources":["./src/utils/lang/extend-method.ts","./src/utils/stencil/component-behavior.ts"],"sourcesContent":["/**\r\n * Extend a method functionality, applying monkeypatch method.\r\n * @link https://www.audero.it/blog/2016/12/05/monkey-patching-javascript/\r\n * @param target The target object.\r\n * @param method The name of the method that will be extended.\r\n * @param extend The method's patch.\r\n */\r\nexport function extendMethod(target: any, method: string, extend: (original: Function, args?: any[]) => any) {\r\n  const original = target[method];\r\n\r\n  target['__' + method + '__patch_list'] = target['__' + method + '__patches'] || [];\r\n  const patchList = target['__' + method + '__patch_list'];\r\n\r\n  patchList.push(extend);\r\n\r\n  target[method] = function(...args) {\r\n    let lastResult;\r\n    for (const patch of patchList) {\r\n      lastResult = patch.bind(this)(original ? original.bind(this) : null, args);\r\n    }\r\n    return lastResult;\r\n  };\r\n}\r\n","import { ComponentInterface } from '@stencil/core';\r\n\r\nimport { extendMethod } from '../lang/extend-method';\r\n\r\n/**\r\n * Represents a Component that implements a Behavior Modification API.\r\n */\r\nexport interface ComponentBase extends ComponentInterface {\r\n  /**\r\n   * The main native nativeElement from the component.\r\n   * @Element\r\n   */\r\n  host: HTMLElement;\r\n\r\n  /**\r\n   * The unload lifecycle hook.\r\n   * Note that Stencil only calls disconnectedCallback if it is declared in the component.\r\n   */\r\n  disconnectedCallback: () => void;\r\n\r\n  /**\r\n   * If this behavior is applied to a native element.\r\n   */\r\n  native?: boolean;\r\n}\r\n\r\n/**\r\n * Represents a Component's Behavior Modification.\r\n */\r\nexport class ComponentBehavior<T extends ComponentBase> {\r\n  /**\r\n   * The internal component that this instance is attached.\r\n   */\r\n  component: T;\r\n\r\n  /**\r\n   * A hook called before the component load.\r\n   */\r\n  beforeAttach?(): Promise<any> | void;\r\n\r\n  /**\r\n   * A hook called after the component load.\r\n   */\r\n  attach?(): Promise<any> | void;\r\n\r\n  /**\r\n   * A hook called before the component destroy.\r\n   */\r\n  detach?(): Promise<any> | void;\r\n\r\n  constructor(component: T) {\r\n    this.component = component;\r\n    if (this.beforeAttach) { this.beforeAttach(); }\r\n\r\n    // Native Elements support\r\n    if (this.component.native) {\r\n      console.warn('Attaching a behavior to a native element', this.component);\r\n      this.component.host.remove = () => {\r\n        this.component.disconnectedCallback();\r\n        Element.prototype.remove.apply(this.component.host);\r\n      };\r\n      setTimeout(() => this.component.componentDidLoad(), 0);\r\n    }\r\n\r\n    extendMethod(this.component, 'componentDidLoad', componentDidLoad => {\r\n      if (componentDidLoad) { componentDidLoad(); }\r\n      if (this.attach) { this.attach(); }\r\n    });\r\n\r\n    extendMethod(this.component, 'disconnectedCallback', disconnectedCallback => {\r\n      if (disconnectedCallback) { disconnectedCallback(); }\r\n      if (this.detach) { this.detach(); }\r\n    });\r\n  }\r\n}\r\n"],"version":3}